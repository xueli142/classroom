{"version":3,"file":"mapToObjects.js","names":["_Number","_interopRequireDefault","require","_String","_Boolean","_Date","_excluded","obj","__esModule","_typeof","o","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","r","l","t","e","n","u","a","f","call","next","Object","done","push","value","length","Array","isArray","_createForOfIteratorHelperLoose","allowArrayLike","it","bind","minLen","_arrayLikeToArray","toString","slice","name","from","test","len","arr2","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","key","getOwnPropertySymbols","sourceSymbolKeys","indexOf","propertyIsEnumerable","sourceKeys","keys","ownKeys","filter","getOwnPropertyDescriptor","enumerable","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","DEFAULT_OPTIONS","schemaPropertyValueForMissingColumn","schemaPropertyValueForMissingValue","schemaPropertyShouldSkipRequiredValidationForMissingColumn","getEmptyObjectValue","getEmptyArrayValue","isColumnOriented","ignoreEmptyRows","arrayValueSeparator","mapToObjects","data","schema","options","_options","rowIndexSourceMapOriginal","rowIndexSourceMap","schemaTransformOptions","validateSchema","transpose","row","isEmptyRow","every","cell","splice","columns","results","errors","result","read","_iterator","_step","error","rows","rowIndex","path","object","isEmptyObject","createError","_ref","schemaEntry","errorMessage","reason","column","type","pendingRequiredChecks","_loop","_Object$keys","_i","propertyName","columnTitle","propertyPath","concat","cellValue","columnIndex","isMissingColumn","array","parseArray","map","_value","parseValue","isEmpty","isEmptyValue","required","_i2","_pendingRequiredCheck","_pendingRequiredCheck2","skipRequiredValidation","isRequired","parse","Error","parseValueOfType","oneOf","validate","message","parseCustomValue","parsedValue","StringType","NumberType","Date","DateType","properties","Boolean","BooleanType","getBlock","string","endCharacter","startIndex","substring","character","block","blocks","index","_getBlock","_getBlock2","trim","_","_i3","_Object$keys2"],"sources":["../../../source/read/schema/mapToObjects.js"],"sourcesContent":["import NumberType from '../../types/Number.js'\r\nimport StringType from '../../types/String.js'\r\nimport BooleanType from '../../types/Boolean.js'\r\nimport DateType from '../../types/Date.js'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  schemaPropertyValueForMissingColumn: undefined,\r\n  schemaPropertyValueForMissingValue: null,\r\n  schemaPropertyShouldSkipRequiredValidationForMissingColumn: () => false,\r\n  // `getEmptyObjectValue(object, { path })` applies to both the top-level object\r\n  // and any of its sub-objects.\r\n  getEmptyObjectValue: () => null,\r\n  getEmptyArrayValue: () => null,\r\n  isColumnOriented: false,\r\n  ignoreEmptyRows: true,\r\n  arrayValueSeparator: ','\r\n}\r\n\r\n/**\r\n * Converts spreadsheet-alike data structure into an array of objects.\r\n *\r\n * Parameters:\r\n *\r\n * * `data` — An array of rows, each row being an array of cells. The first row should be the list of column headers and the rest of the rows should be the data.\r\n * * `schema` — A \"to JSON\" convertion schema (see above).\r\n * * `options` — (optional) Schema conversion parameters of `read-excel-file`:\r\n *   * `schemaPropertyValueForMissingColumn` — By default, when some of the `schema` columns are missing in the input `data`, those properties are set to `undefined` in the output objects. Pass `schemaPropertyValueForMissingColumn: null` to set such \"missing column\" properties to `null` in the output objects.\r\n *   * `schemaPropertyValueForNullCellValue` — By default, when it encounters a `null` value in a cell in input `data`, it sets it to `undefined` in the output object. Pass `schemaPropertyValueForNullCellValue: null` to make it set such values as `null`s in output objects.\r\n *   * `schemaPropertyValueForUndefinedCellValue` — By default, when it encounters an `undefined` value in a cell in input `data`, it it sets it to `undefined` in the output object. Pass `schemaPropertyValueForUndefinedCellValue: null` to make it set such values as `null`s in output objects.\r\n *   * `schemaPropertyShouldSkipRequiredValidationForMissingColumn: (column: string, { object }) => boolean` — By default, it does apply `required` validation to `schema` properties for which columns are missing in the input `data`. One could pass a custom `schemaPropertyShouldSkipRequiredValidationForMissingColumn(column, { object })` to disable `required` validation for missing columns in some or all cases.\r\n *   * `getEmptyObjectValue(object, { path? })` — By default, it returns `null` for \"empty\" objects. One could override that value using `getEmptyObjectValue(object, { path })` parameter. The value applies to both top-level object and any nested sub-objects in case of a nested schema, hence the additional (optional) `path?: string` parameter.\r\n *   * `getEmptyArrayValue(array, { path })` — By default, it returns `null` for an \"empty\" array value. One could override that value using `getEmptyArrayValue(array, { path })` parameter.\r\n *\r\n * When parsing a property value, in case of an error, the value of that property is gonna be `undefined`.\r\n *\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @param {object} [options]\r\n * @param {null} [options.schemaPropertyValueForMissingColumn] — By default, when some of the `schema` columns are missing in the input `data`, those properties are set to `undefined` in the output objects. Pass `schemaPropertyValueForMissingColumn: null` to set such \"missing column\" properties to `null` in the output objects.\r\n * @param {null} [options.schemaPropertyValueForMissingValue] — By default, when it encounters a `null` value in a cell in input `data`, it leaves the value as is. Pass a custom `schemaPropertyValueForMissingValue` to make it set such values to that value.\r\n * @param {object} [options.properties] — An optional object with optional property `epoch1904: true/false`. It is used when parsing dates.\r\n * @param {boolean} [options.schemaPropertyShouldSkipRequiredValidationForMissingColumn(column: string, { object })] — By default, it does apply `required` validation to `schema` properties for which columns are missing in the input `data`. One could pass a custom `schemaPropertyShouldSkipRequiredValidationForMissingColumn(column, { object })` to disable `required` validation for missing columns in some or all cases.\r\n * @param {function} [options.getEmptyObjectValue(object, { path })] — By default, it returns `null` for an \"empty\" resulting object. One could override that value using `getEmptyObjectValue(object, { path })` parameter. The value applies to both top-level object and any nested sub-objects in case of a nested schema, hence the additional `path?: string` parameter.\r\n * @param {function} [getEmptyArrayValue(array, { path })] — By default, it returns `null` for an \"empty\" array value. One could override that value using `getEmptyArrayValue(array, { path })` parameter.\r\n * @param {boolean} [options.isColumnOriented] — By default, the headers are assumed to be the first row in the `data`. Pass `isColumnOriented: true` if the headers are the first column in the `data`. i.e. if `data` is \"transposed\".\r\n * @param {string} [options.arrayValueSeparator] — When specified, string values will be split by this separator to get the array.\r\n * @param {object} [options.rowIndexSourceMap] — Custom row indexes of `data` rows. If present, will overwrite the indexes of `data` rows with the indexes from this `rowIndexSourceMap`.\r\n * @return {object[]}\r\n */\r\nexport default function mapToObjects(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    ignoreEmptyRows,\r\n    rowIndexSourceMap: rowIndexSourceMapOriginal,\r\n    ...schemaTransformOptions\r\n  } = options\r\n\r\n  // `rowIndexSourceMap` could be mutated by `ignoreEmptyRows: true` option.\r\n  // Create a copy of it so that the original `rowIndexSourceMap` is not affected by those changes.\r\n  let rowIndexSourceMap = rowIndexSourceMapOriginal && rowIndexSourceMapOriginal.slice()\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n\tif (ignoreEmptyRows) {\r\n\t\tdata = data.filter((row, i) => {\r\n      const isEmptyRow = row.every(cell => cell === null)\r\n      if (isEmptyRow) {\r\n        // Adjust `rowIndexSourceMap` now that the row has been removed.\r\n        if (rowIndexSourceMap) {\r\n          // Remove the `rowIndexSourceMap` entry that corresponds to the removed row.\r\n          rowIndexSourceMap.splice(i, 1)\r\n        }\r\n        return false;\r\n      }\r\n      return true;\r\n    })\r\n\t}\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i, undefined, columns, errors, schemaTransformOptions)\r\n    results.push(result)\r\n  }\r\n\r\n  // Set the correct `row` number in `errors` if a custom `rowIndexSourceMap` is supplied.\r\n  if (rowIndexSourceMap) {\r\n    for (const error of errors) {\r\n      // Convert the `row` index in `data` to the\r\n      // actual `row` index in the spreadsheet.\r\n      // `- 1` converts row number to row index.\r\n      // `+ 1` converts row index to row number.\r\n      error.row = rowIndexSourceMap[error.row - 1] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, path, columns, errors, options) {\r\n  const object = {}\r\n  let isEmptyObject = true\r\n\r\n  const createError = ({\r\n    schemaEntry,\r\n    value,\r\n    error: errorMessage,\r\n    reason\r\n  }) => {\r\n    const error = {\r\n      error: errorMessage,\r\n      row: rowIndex + 1,\r\n      column: schemaEntry.column,\r\n      value\r\n    }\r\n    if (reason) {\r\n      error.reason = reason\r\n    }\r\n    // * Regular values specify a `type?` property, which is included in the `error` object.\r\n    // * Nested objects specify a `schema` property, which is not included in the `error` object.\r\n    if (schemaEntry.type) {\r\n      error.type = schemaEntry.type\r\n    }\r\n    return error\r\n  }\r\n\r\n  const pendingRequiredChecks = []\r\n\r\n  // For each schema entry.\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n\r\n    // `schemaEntry.prop` property is now deprecated and shouldn't be used.\r\n    // Instead, it now uses `key` as the key in the `object`.\r\n    // And column name is now read not from `key` but from `schemaEntry.column` property.\r\n    const propertyName = key\r\n    const columnTitle = schemaEntry.column\r\n\r\n    // The path of this property inside the resulting object.\r\n    const propertyPath = `${path || ''}.${propertyName}`\r\n\r\n    // Read the cell value for the schema entry.\r\n    let cellValue\r\n    const columnIndex = columns.indexOf(columnTitle)\r\n    const isMissingColumn = columnIndex < 0\r\n    if (!isMissingColumn) {\r\n      cellValue = row[columnIndex]\r\n    }\r\n\r\n    let value\r\n    let error\r\n    let reason\r\n\r\n    // Get property `value` from cell value.\r\n    if (schemaEntry.schema) {\r\n      value = read(schemaEntry.schema, row, rowIndex, propertyPath, columns, errors, options)\r\n    } else {\r\n      if (isMissingColumn) {\r\n        if ('schemaPropertyValueForMissingColumn' in options) {\r\n          value = options.schemaPropertyValueForMissingColumn\r\n        }\r\n      }\r\n      else if (cellValue === undefined) {\r\n        // This isn't supposed to be possible. Cell values are always `null` when cells are empty.\r\n        // Employ some sensible fallback behavior here.\r\n        if ('schemaPropertyValueForMissingValue' in options) {\r\n          value = options.schemaPropertyValueForMissingValue\r\n        }\r\n      }\r\n      else if (cellValue === null) {\r\n        if ('schemaPropertyValueForMissingValue' in options) {\r\n          value = options.schemaPropertyValueForMissingValue\r\n        }\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        const array = parseArray(cellValue, options.arrayValueSeparator).map((_value) => {\r\n          if (error) {\r\n            return\r\n          }\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            // In case of an error, `value` won't be returned and will just be reported\r\n            // as part of an `error` object, so it's fine assigning just an element of the array.\r\n            value = _value\r\n            error = result.error\r\n            reason = result.reason\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          const isEmpty = array.every(isEmptyValue)\r\n          value = isEmpty ? options.getEmptyArrayValue(array, { path: propertyPath }) : array\r\n        }\r\n      } else {\r\n        const result = parseValue(cellValue, schemaEntry, options)\r\n        error = result.error\r\n        reason = result.reason\r\n        value = error ? cellValue : result.value\r\n      }\r\n    }\r\n\r\n    // Apply `required` validation if the value is \"empty\".\r\n    if (!error && isEmptyValue(value)) {\r\n      if (schemaEntry.required) {\r\n        // Will perform this `required()` validation in the end,\r\n        // when all properties of the mapped object have been mapped.\r\n        pendingRequiredChecks.push({ schemaEntry, value, isMissingColumn })\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      // If there was an error then the property value in the `object` will be `undefined`,\r\n      // i.e it won't add the property value to the mapped object.\r\n      errors.push(createError({\r\n        schemaEntry,\r\n        value,\r\n        error,\r\n        reason\r\n      }))\r\n    } else {\r\n      // Possibly unmark the mapped object as \"empty\".\r\n      if (isEmptyObject && !isEmptyValue(value)) {\r\n        isEmptyObject = false\r\n      }\r\n      // Set the value in the mapped object.\r\n      // Skip setting `undefined` values because they're already `undefined`\r\n      // due to not having previously been set.\r\n      if (value !== undefined) {\r\n        object[propertyName] = value\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return `null` for an \"empty\" mapped object.\r\n  if (isEmptyObject) {\r\n    return options.getEmptyObjectValue(object, { path })\r\n  }\r\n\r\n  // Perform any `required` validations.\r\n  for (const { schemaEntry, value, isMissingColumn } of pendingRequiredChecks) {\r\n    // Can optionally skip `required` validation for missing columns.\r\n    const skipRequiredValidation = isMissingColumn && options.schemaPropertyShouldSkipRequiredValidationForMissingColumn(schemaEntry.column, { object })\r\n    if (!skipRequiredValidation) {\r\n      const { required } = schemaEntry\r\n      const isRequired = typeof required === 'boolean' ? required : required(object)\r\n      if (isRequired) {\r\n        errors.push(createError({\r\n          schemaEntry,\r\n          value,\r\n          error: 'required'\r\n        }))\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return the mapped object.\r\n  return object\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    throw new Error('`schemaEntry.parse` property was renamed to `schemaEntry.type`')\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(\r\n      value,\r\n      // Supports parsing array types.\r\n      // See `parseArray()` function for more details.\r\n      // Example `type`: String[]\r\n      // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\r\n      // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\r\n      Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type,\r\n      options\r\n    )\r\n  } else {\r\n    result = { value: value }\r\n    // throw new Error('Invalid schema entry: no `type` specified:\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null) {\r\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\r\n      return { error: 'invalid', reason: 'unknown' }\r\n    }\r\n    if (schemaEntry.validate) {\r\n      try {\r\n        schemaEntry.validate(result.value)\r\n      } catch (error) {\r\n        return { error: error.message }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    const parsedValue = parse(value)\r\n    if (parsedValue === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value: parsedValue }\r\n  } catch (error) {\r\n    const result = { error: error.message }\r\n    if (error.reason) {\r\n      result.reason = error.reason;\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string, reason?: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      return parseCustomValue(value, StringType)\r\n\r\n    case Number:\r\n      return parseCustomValue(value, NumberType)\r\n\r\n    case Date:\r\n      return parseCustomValue(value, (value) => DateType(value, { properties: options.properties }))\r\n\r\n    case Boolean:\r\n      return parseCustomValue(value, BooleanType)\r\n\r\n    default:\r\n      if (typeof type === 'function') {\r\n        return parseCustomValue(value, type)\r\n      }\r\n      throw new Error(`Unsupported schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\r\nexport function parseArray(string, arrayValueSeparator) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, arrayValueSeparator, index)\r\n    index += length + arrayValueSeparator.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    // Validate that the `schema` is not using a deprecated `type: nestedSchema` format.\r\n    if (typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)) {\r\n      throw new Error('When defining a nested schema, use a `schema` property instead of a `type` property')\r\n    }\r\n    // Validate that every property has a source `column` title specified for it.\r\n    if (!schemaEntry.schema) {\r\n      if (!schemaEntry.column) {\r\n        throw new Error(`\"column\" not defined for schema entry \"${key}\".`)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction isEmptyValue(value) {\r\n  return value === undefined || value === null\r\n}"],"mappings":";;;;;;;;;AAAA,IAAAA,OAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,OAAA,GAAAF,sBAAA,CAAAC,OAAA;AACA,IAAAE,QAAA,GAAAH,sBAAA,CAAAC,OAAA;AACA,IAAAG,KAAA,GAAAJ,sBAAA,CAAAC,OAAA;AAA0C,IAAAI,SAAA;AAAA,SAAAL,uBAAAM,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,gBAAAA,GAAA;AAAA,SAAAE,QAAAC,CAAA,sCAAAD,OAAA,wBAAAE,MAAA,uBAAAA,MAAA,CAAAC,QAAA,aAAAF,CAAA,kBAAAA,CAAA,gBAAAA,CAAA,WAAAA,CAAA,yBAAAC,MAAA,IAAAD,CAAA,CAAAG,WAAA,KAAAF,MAAA,IAAAD,CAAA,KAAAC,MAAA,CAAAG,SAAA,qBAAAJ,CAAA,KAAAD,OAAA,CAAAC,CAAA;AAAA,SAAAK,eAAAC,GAAA,EAAAC,CAAA,WAAAC,eAAA,CAAAF,GAAA,KAAAG,qBAAA,CAAAH,GAAA,EAAAC,CAAA,KAAAG,2BAAA,CAAAJ,GAAA,EAAAC,CAAA,KAAAI,gBAAA;AAAA,SAAAA,iBAAA,cAAAC,SAAA;AAAA,SAAAH,sBAAAI,CAAA,EAAAC,CAAA,QAAAC,CAAA,WAAAF,CAAA,gCAAAZ,MAAA,IAAAY,CAAA,CAAAZ,MAAA,CAAAC,QAAA,KAAAW,CAAA,4BAAAE,CAAA,QAAAC,CAAA,EAAAC,CAAA,EAAAV,CAAA,EAAAW,CAAA,EAAAC,CAAA,OAAAC,CAAA,OAAApB,CAAA,iBAAAO,CAAA,IAAAQ,CAAA,GAAAA,CAAA,CAAAM,IAAA,CAAAR,CAAA,GAAAS,IAAA,QAAAR,CAAA,QAAAS,MAAA,CAAAR,CAAA,MAAAA,CAAA,UAAAK,CAAA,uBAAAA,CAAA,IAAAJ,CAAA,GAAAT,CAAA,CAAAc,IAAA,CAAAN,CAAA,GAAAS,IAAA,MAAAL,CAAA,CAAAM,IAAA,CAAAT,CAAA,CAAAU,KAAA,GAAAP,CAAA,CAAAQ,MAAA,KAAAb,CAAA,GAAAM,CAAA,iBAAAP,CAAA,IAAAb,CAAA,OAAAiB,CAAA,GAAAJ,CAAA,yBAAAO,CAAA,YAAAL,CAAA,eAAAG,CAAA,GAAAH,CAAA,cAAAQ,MAAA,CAAAL,CAAA,MAAAA,CAAA,2BAAAlB,CAAA,QAAAiB,CAAA,aAAAE,CAAA;AAAA,SAAAX,gBAAAF,GAAA,QAAAsB,KAAA,CAAAC,OAAA,CAAAvB,GAAA,UAAAA,GAAA;AAAA,SAAAwB,gCAAA9B,CAAA,EAAA+B,cAAA,QAAAC,EAAA,UAAA/B,MAAA,oBAAAD,CAAA,CAAAC,MAAA,CAAAC,QAAA,KAAAF,CAAA,oBAAAgC,EAAA,UAAAA,EAAA,GAAAA,EAAA,CAAAX,IAAA,CAAArB,CAAA,GAAAsB,IAAA,CAAAW,IAAA,CAAAD,EAAA,OAAAJ,KAAA,CAAAC,OAAA,CAAA7B,CAAA,MAAAgC,EAAA,GAAAtB,2BAAA,CAAAV,CAAA,MAAA+B,cAAA,IAAA/B,CAAA,WAAAA,CAAA,CAAA2B,MAAA,qBAAAK,EAAA,EAAAhC,CAAA,GAAAgC,EAAA,MAAAzB,CAAA,+BAAAA,CAAA,IAAAP,CAAA,CAAA2B,MAAA,WAAAH,IAAA,mBAAAA,IAAA,SAAAE,KAAA,EAAA1B,CAAA,CAAAO,CAAA,sBAAAK,SAAA;AAAA,SAAAF,4BAAAV,CAAA,EAAAkC,MAAA,SAAAlC,CAAA,qBAAAA,CAAA,sBAAAmC,iBAAA,CAAAnC,CAAA,EAAAkC,MAAA,OAAAjB,CAAA,GAAAM,MAAA,CAAAnB,SAAA,CAAAgC,QAAA,CAAAf,IAAA,CAAArB,CAAA,EAAAqC,KAAA,aAAApB,CAAA,iBAAAjB,CAAA,CAAAG,WAAA,EAAAc,CAAA,GAAAjB,CAAA,CAAAG,WAAA,CAAAmC,IAAA,MAAArB,CAAA,cAAAA,CAAA,mBAAAW,KAAA,CAAAW,IAAA,CAAAvC,CAAA,OAAAiB,CAAA,+DAAAuB,IAAA,CAAAvB,CAAA,UAAAkB,iBAAA,CAAAnC,CAAA,EAAAkC,MAAA;AAAA,SAAAC,kBAAA7B,GAAA,EAAAmC,GAAA,QAAAA,GAAA,YAAAA,GAAA,GAAAnC,GAAA,CAAAqB,MAAA,EAAAc,GAAA,GAAAnC,GAAA,CAAAqB,MAAA,WAAApB,CAAA,MAAAmC,IAAA,OAAAd,KAAA,CAAAa,GAAA,GAAAlC,CAAA,GAAAkC,GAAA,EAAAlC,CAAA,IAAAmC,IAAA,CAAAnC,CAAA,IAAAD,GAAA,CAAAC,CAAA,UAAAmC,IAAA;AAAA,SAAAC,yBAAAC,MAAA,EAAAC,QAAA,QAAAD,MAAA,yBAAAE,MAAA,GAAAC,6BAAA,CAAAH,MAAA,EAAAC,QAAA,OAAAG,GAAA,EAAAzC,CAAA,MAAAgB,MAAA,CAAA0B,qBAAA,QAAAC,gBAAA,GAAA3B,MAAA,CAAA0B,qBAAA,CAAAL,MAAA,QAAArC,CAAA,MAAAA,CAAA,GAAA2C,gBAAA,CAAAvB,MAAA,EAAApB,CAAA,MAAAyC,GAAA,GAAAE,gBAAA,CAAA3C,CAAA,OAAAsC,QAAA,CAAAM,OAAA,CAAAH,GAAA,uBAAAzB,MAAA,CAAAnB,SAAA,CAAAgD,oBAAA,CAAA/B,IAAA,CAAAuB,MAAA,EAAAI,GAAA,aAAAF,MAAA,CAAAE,GAAA,IAAAJ,MAAA,CAAAI,GAAA,cAAAF,MAAA;AAAA,SAAAC,8BAAAH,MAAA,EAAAC,QAAA,QAAAD,MAAA,yBAAAE,MAAA,WAAAO,UAAA,GAAA9B,MAAA,CAAA+B,IAAA,CAAAV,MAAA,OAAAI,GAAA,EAAAzC,CAAA,OAAAA,CAAA,MAAAA,CAAA,GAAA8C,UAAA,CAAA1B,MAAA,EAAApB,CAAA,MAAAyC,GAAA,GAAAK,UAAA,CAAA9C,CAAA,OAAAsC,QAAA,CAAAM,OAAA,CAAAH,GAAA,kBAAAF,MAAA,CAAAE,GAAA,IAAAJ,MAAA,CAAAI,GAAA,YAAAF,MAAA;AAAA,SAAAS,QAAAvC,CAAA,EAAAH,CAAA,QAAAE,CAAA,GAAAQ,MAAA,CAAA+B,IAAA,CAAAtC,CAAA,OAAAO,MAAA,CAAA0B,qBAAA,QAAAjD,CAAA,GAAAuB,MAAA,CAAA0B,qBAAA,CAAAjC,CAAA,GAAAH,CAAA,KAAAb,CAAA,GAAAA,CAAA,CAAAwD,MAAA,WAAA3C,CAAA,WAAAU,MAAA,CAAAkC,wBAAA,CAAAzC,CAAA,EAAAH,CAAA,EAAA6C,UAAA,OAAA3C,CAAA,CAAAU,IAAA,CAAAkC,KAAA,CAAA5C,CAAA,EAAAf,CAAA,YAAAe,CAAA;AAAA,SAAA6C,cAAA5C,CAAA,aAAAH,CAAA,MAAAA,CAAA,GAAAgD,SAAA,CAAAlC,MAAA,EAAAd,CAAA,UAAAE,CAAA,WAAA8C,SAAA,CAAAhD,CAAA,IAAAgD,SAAA,CAAAhD,CAAA,QAAAA,CAAA,OAAA0C,OAAA,CAAAhC,MAAA,CAAAR,CAAA,OAAA+C,OAAA,WAAAjD,CAAA,IAAAkD,eAAA,CAAA/C,CAAA,EAAAH,CAAA,EAAAE,CAAA,CAAAF,CAAA,SAAAU,MAAA,CAAAyC,yBAAA,GAAAzC,MAAA,CAAA0C,gBAAA,CAAAjD,CAAA,EAAAO,MAAA,CAAAyC,yBAAA,CAAAjD,CAAA,KAAAwC,OAAA,CAAAhC,MAAA,CAAAR,CAAA,GAAA+C,OAAA,WAAAjD,CAAA,IAAAU,MAAA,CAAA2C,cAAA,CAAAlD,CAAA,EAAAH,CAAA,EAAAU,MAAA,CAAAkC,wBAAA,CAAA1C,CAAA,EAAAF,CAAA,iBAAAG,CAAA;AAAA,SAAA+C,gBAAAlE,GAAA,EAAAmD,GAAA,EAAAtB,KAAA,IAAAsB,GAAA,GAAAmB,cAAA,CAAAnB,GAAA,OAAAA,GAAA,IAAAnD,GAAA,IAAA0B,MAAA,CAAA2C,cAAA,CAAArE,GAAA,EAAAmD,GAAA,IAAAtB,KAAA,EAAAA,KAAA,EAAAgC,UAAA,QAAAU,YAAA,QAAAC,QAAA,oBAAAxE,GAAA,CAAAmD,GAAA,IAAAtB,KAAA,WAAA7B,GAAA;AAAA,SAAAsE,eAAAG,GAAA,QAAAtB,GAAA,GAAAuB,YAAA,CAAAD,GAAA,oBAAAvE,OAAA,CAAAiD,GAAA,iBAAAA,GAAA,GAAAwB,MAAA,CAAAxB,GAAA;AAAA,SAAAuB,aAAAE,KAAA,EAAAC,IAAA,QAAA3E,OAAA,CAAA0E,KAAA,kBAAAA,KAAA,kBAAAA,KAAA,MAAAE,IAAA,GAAAF,KAAA,CAAAxE,MAAA,CAAA2E,WAAA,OAAAD,IAAA,KAAAE,SAAA,QAAAC,GAAA,GAAAH,IAAA,CAAAtD,IAAA,CAAAoD,KAAA,EAAAC,IAAA,oBAAA3E,OAAA,CAAA+E,GAAA,uBAAAA,GAAA,YAAAlE,SAAA,4DAAA8D,IAAA,gBAAAF,MAAA,GAAAO,MAAA,EAAAN,KAAA;AAE1C,IAAMO,eAAe,GAAG;EACtBC,mCAAmC,EAAEJ,SAAS;EAC9CK,kCAAkC,EAAE,IAAI;EACxCC,0DAA0D,EAAE,SAAAA,2DAAA;IAAA,OAAM,KAAK;EAAA;EACvE;EACA;EACAC,mBAAmB,EAAE,SAAAA,oBAAA;IAAA,OAAM,IAAI;EAAA;EAC/BC,kBAAkB,EAAE,SAAAA,mBAAA;IAAA,OAAM,IAAI;EAAA;EAC9BC,gBAAgB,EAAE,KAAK;EACvBC,eAAe,EAAE,IAAI;EACrBC,mBAAmB,EAAE;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASC,YAAYA,CAACC,IAAI,EAAEC,MAAM,EAAEC,OAAO,EAAE;EAC1D,IAAIA,OAAO,EAAE;IACXA,OAAO,GAAAhC,aAAA,CAAAA,aAAA,KACFoB,eAAe,GACfY,OAAO,CACX;EACH,CAAC,MAAM;IACLA,OAAO,GAAGZ,eAAe;EAC3B;EAEA,IAAAa,QAAA,GAKID,OAAO;IAJTN,gBAAgB,GAAAO,QAAA,CAAhBP,gBAAgB;IAChBC,eAAe,GAAAM,QAAA,CAAfN,eAAe;IACIO,yBAAyB,GAAAD,QAAA,CAA5CE,iBAAiB;IACdC,sBAAsB,GAAArD,wBAAA,CAAAkD,QAAA,EAAAjG,SAAA;;EAG3B;EACA;EACA,IAAImG,iBAAiB,GAAGD,yBAAyB,IAAIA,yBAAyB,CAACzD,KAAK,CAAC,CAAC;EAEtF4D,cAAc,CAACN,MAAM,CAAC;EAEtB,IAAIL,gBAAgB,EAAE;IACpBI,IAAI,GAAGQ,SAAS,CAACR,IAAI,CAAC;EACxB;EAED,IAAIH,eAAe,EAAE;IACpBG,IAAI,GAAGA,IAAI,CAAClC,MAAM,CAAC,UAAC2C,GAAG,EAAE5F,CAAC,EAAK;MAC3B,IAAM6F,UAAU,GAAGD,GAAG,CAACE,KAAK,CAAC,UAAAC,IAAI;QAAA,OAAIA,IAAI,KAAK,IAAI;MAAA,EAAC;MACnD,IAAIF,UAAU,EAAE;QACd;QACA,IAAIL,iBAAiB,EAAE;UACrB;UACAA,iBAAiB,CAACQ,MAAM,CAAChG,CAAC,EAAE,CAAC,CAAC;QAChC;QACA,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb,CAAC,CAAC;EACL;EAEC,IAAMiG,OAAO,GAAGd,IAAI,CAAC,CAAC,CAAC;EAEvB,IAAMe,OAAO,GAAG,EAAE;EAClB,IAAMC,MAAM,GAAG,EAAE;EAEjB,KAAK,IAAInG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmF,IAAI,CAAC/D,MAAM,EAAEpB,CAAC,EAAE,EAAE;IACpC,IAAMoG,MAAM,GAAGC,IAAI,CAACjB,MAAM,EAAED,IAAI,CAACnF,CAAC,CAAC,EAAEA,CAAC,EAAEsE,SAAS,EAAE2B,OAAO,EAAEE,MAAM,EAAEV,sBAAsB,CAAC;IAC3FS,OAAO,CAAChF,IAAI,CAACkF,MAAM,CAAC;EACtB;;EAEA;EACA,IAAIZ,iBAAiB,EAAE;IACrB,SAAAc,SAAA,GAAA/E,+BAAA,CAAoB4E,MAAM,GAAAI,KAAA,IAAAA,KAAA,GAAAD,SAAA,IAAArF,IAAA,GAAE;MAAA,IAAjBuF,KAAK,GAAAD,KAAA,CAAApF,KAAA;MACd;MACA;MACA;MACA;MACAqF,KAAK,CAACZ,GAAG,GAAGJ,iBAAiB,CAACgB,KAAK,CAACZ,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC;IAClD;EACF;EAEA,OAAO;IACLa,IAAI,EAAEP,OAAO;IACbC,MAAM,EAANA;EACF,CAAC;AACH;AAEA,SAASE,IAAIA,CAACjB,MAAM,EAAEQ,GAAG,EAAEc,QAAQ,EAAEC,IAAI,EAAEV,OAAO,EAAEE,MAAM,EAAEd,OAAO,EAAE;EACnE,IAAMuB,MAAM,GAAG,CAAC,CAAC;EACjB,IAAIC,aAAa,GAAG,IAAI;EAExB,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAAC,IAAA,EAKX;IAAA,IAJJC,WAAW,GAAAD,IAAA,CAAXC,WAAW;MACX7F,KAAK,GAAA4F,IAAA,CAAL5F,KAAK;MACE8F,YAAY,GAAAF,IAAA,CAAnBP,KAAK;MACLU,MAAM,GAAAH,IAAA,CAANG,MAAM;IAEN,IAAMV,KAAK,GAAG;MACZA,KAAK,EAAES,YAAY;MACnBrB,GAAG,EAAEc,QAAQ,GAAG,CAAC;MACjBS,MAAM,EAAEH,WAAW,CAACG,MAAM;MAC1BhG,KAAK,EAALA;IACF,CAAC;IACD,IAAI+F,MAAM,EAAE;MACVV,KAAK,CAACU,MAAM,GAAGA,MAAM;IACvB;IACA;IACA;IACA,IAAIF,WAAW,CAACI,IAAI,EAAE;MACpBZ,KAAK,CAACY,IAAI,GAAGJ,WAAW,CAACI,IAAI;IAC/B;IACA,OAAOZ,KAAK;EACd,CAAC;EAED,IAAMa,qBAAqB,GAAG,EAAE;;EAEhC;EAAA,IAAAC,KAAA,YAAAA,MAAA,EACuC;IAAlC,IAAM7E,GAAG,GAAA8E,YAAA,CAAAC,EAAA;IACZ,IAAMR,WAAW,GAAG5B,MAAM,CAAC3C,GAAG,CAAC;;IAE/B;IACA;IACA;IACA,IAAMgF,YAAY,GAAGhF,GAAG;IACxB,IAAMiF,WAAW,GAAGV,WAAW,CAACG,MAAM;;IAEtC;IACA,IAAMQ,YAAY,MAAAC,MAAA,CAAMjB,IAAI,IAAI,EAAE,OAAAiB,MAAA,CAAIH,YAAY,CAAE;;IAEpD;IACA,IAAII,SAAS;IACb,IAAMC,WAAW,GAAG7B,OAAO,CAACrD,OAAO,CAAC8E,WAAW,CAAC;IAChD,IAAMK,eAAe,GAAGD,WAAW,GAAG,CAAC;IACvC,IAAI,CAACC,eAAe,EAAE;MACpBF,SAAS,GAAGjC,GAAG,CAACkC,WAAW,CAAC;IAC9B;IAEA,IAAI3G,KAAK;IACT,IAAIqF,KAAK;IACT,IAAIU,MAAM;;IAEV;IACA,IAAIF,WAAW,CAAC5B,MAAM,EAAE;MACtBjE,KAAK,GAAGkF,IAAI,CAACW,WAAW,CAAC5B,MAAM,EAAEQ,GAAG,EAAEc,QAAQ,EAAEiB,YAAY,EAAE1B,OAAO,EAAEE,MAAM,EAAEd,OAAO,CAAC;IACzF,CAAC,MAAM;MACL,IAAI0C,eAAe,EAAE;QACnB,IAAI,qCAAqC,IAAI1C,OAAO,EAAE;UACpDlE,KAAK,GAAGkE,OAAO,CAACX,mCAAmC;QACrD;MACF,CAAC,MACI,IAAImD,SAAS,KAAKvD,SAAS,EAAE;QAChC;QACA;QACA,IAAI,oCAAoC,IAAIe,OAAO,EAAE;UACnDlE,KAAK,GAAGkE,OAAO,CAACV,kCAAkC;QACpD;MACF,CAAC,MACI,IAAIkD,SAAS,KAAK,IAAI,EAAE;QAC3B,IAAI,oCAAoC,IAAIxC,OAAO,EAAE;UACnDlE,KAAK,GAAGkE,OAAO,CAACV,kCAAkC;QACpD;MACF,CAAC,MACI,IAAItD,KAAK,CAACC,OAAO,CAAC0F,WAAW,CAACI,IAAI,CAAC,EAAE;QACxC,IAAMY,KAAK,GAAGC,UAAU,CAACJ,SAAS,EAAExC,OAAO,CAACJ,mBAAmB,CAAC,CAACiD,GAAG,CAAC,UAACC,MAAM,EAAK;UAC/E,IAAI3B,KAAK,EAAE;YACT;UACF;UACA,IAAMJ,MAAM,GAAGgC,UAAU,CAACD,MAAM,EAAEnB,WAAW,EAAE3B,OAAO,CAAC;UACvD,IAAIe,MAAM,CAACI,KAAK,EAAE;YAChB;YACA;YACArF,KAAK,GAAGgH,MAAM;YACd3B,KAAK,GAAGJ,MAAM,CAACI,KAAK;YACpBU,MAAM,GAAGd,MAAM,CAACc,MAAM;UACxB;UACA,OAAOd,MAAM,CAACjF,KAAK;QACrB,CAAC,CAAC;QACF,IAAI,CAACqF,KAAK,EAAE;UACV,IAAM6B,OAAO,GAAGL,KAAK,CAAClC,KAAK,CAACwC,YAAY,CAAC;UACzCnH,KAAK,GAAGkH,OAAO,GAAGhD,OAAO,CAACP,kBAAkB,CAACkD,KAAK,EAAE;YAAErB,IAAI,EAAEgB;UAAa,CAAC,CAAC,GAAGK,KAAK;QACrF;MACF,CAAC,MAAM;QACL,IAAM5B,MAAM,GAAGgC,UAAU,CAACP,SAAS,EAAEb,WAAW,EAAE3B,OAAO,CAAC;QAC1DmB,KAAK,GAAGJ,MAAM,CAACI,KAAK;QACpBU,MAAM,GAAGd,MAAM,CAACc,MAAM;QACtB/F,KAAK,GAAGqF,KAAK,GAAGqB,SAAS,GAAGzB,MAAM,CAACjF,KAAK;MAC1C;IACF;;IAEA;IACA,IAAI,CAACqF,KAAK,IAAI8B,YAAY,CAACnH,KAAK,CAAC,EAAE;MACjC,IAAI6F,WAAW,CAACuB,QAAQ,EAAE;QACxB;QACA;QACAlB,qBAAqB,CAACnG,IAAI,CAAC;UAAE8F,WAAW,EAAXA,WAAW;UAAE7F,KAAK,EAALA,KAAK;UAAE4G,eAAe,EAAfA;QAAgB,CAAC,CAAC;MACrE;IACF;IAEA,IAAIvB,KAAK,EAAE;MACT;MACA;MACAL,MAAM,CAACjF,IAAI,CAAC4F,WAAW,CAAC;QACtBE,WAAW,EAAXA,WAAW;QACX7F,KAAK,EAALA,KAAK;QACLqF,KAAK,EAALA,KAAK;QACLU,MAAM,EAANA;MACF,CAAC,CAAC,CAAC;IACL,CAAC,MAAM;MACL;MACA,IAAIL,aAAa,IAAI,CAACyB,YAAY,CAACnH,KAAK,CAAC,EAAE;QACzC0F,aAAa,GAAG,KAAK;MACvB;MACA;MACA;MACA;MACA,IAAI1F,KAAK,KAAKmD,SAAS,EAAE;QACvBsC,MAAM,CAACa,YAAY,CAAC,GAAGtG,KAAK;MAC9B;IACF;EACF,CAAC;EAtGD,SAAAqG,EAAA,MAAAD,YAAA,GAAkBvG,MAAM,CAAC+B,IAAI,CAACqC,MAAM,CAAC,EAAAoC,EAAA,GAAAD,YAAA,CAAAnG,MAAA,EAAAoG,EAAA;IAAAF,KAAA;EAAA;;EAwGrC;EACA,IAAIT,aAAa,EAAE;IACjB,OAAOxB,OAAO,CAACR,mBAAmB,CAAC+B,MAAM,EAAE;MAAED,IAAI,EAAJA;IAAK,CAAC,CAAC;EACtD;;EAEA;EACA,SAAA6B,GAAA,MAAAC,qBAAA,GAAsDpB,qBAAqB,EAAAmB,GAAA,GAAAC,qBAAA,CAAArH,MAAA,EAAAoH,GAAA,IAAE;IAAxE,IAAAE,sBAAA,GAAAD,qBAAA,CAAAD,GAAA;MAAQxB,WAAW,GAAA0B,sBAAA,CAAX1B,WAAW;MAAE7F,KAAK,GAAAuH,sBAAA,CAALvH,KAAK;MAAE4G,eAAe,GAAAW,sBAAA,CAAfX,eAAe;IAC9C;IACA,IAAMY,sBAAsB,GAAGZ,eAAe,IAAI1C,OAAO,CAACT,0DAA0D,CAACoC,WAAW,CAACG,MAAM,EAAE;MAAEP,MAAM,EAANA;IAAO,CAAC,CAAC;IACpJ,IAAI,CAAC+B,sBAAsB,EAAE;MAC3B,IAAQJ,QAAQ,GAAKvB,WAAW,CAAxBuB,QAAQ;MAChB,IAAMK,UAAU,GAAG,OAAOL,QAAQ,KAAK,SAAS,GAAGA,QAAQ,GAAGA,QAAQ,CAAC3B,MAAM,CAAC;MAC9E,IAAIgC,UAAU,EAAE;QACdzC,MAAM,CAACjF,IAAI,CAAC4F,WAAW,CAAC;UACtBE,WAAW,EAAXA,WAAW;UACX7F,KAAK,EAALA,KAAK;UACLqF,KAAK,EAAE;QACT,CAAC,CAAC,CAAC;MACL;IACF;EACF;;EAEA;EACA,OAAOI,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASwB,UAAUA,CAACjH,KAAK,EAAE6F,WAAW,EAAE3B,OAAO,EAAE;EACtD,IAAIlE,KAAK,KAAK,IAAI,EAAE;IAClB,OAAO;MAAEA,KAAK,EAAE;IAAK,CAAC;EACxB;EACA,IAAIiF,MAAM;EACV,IAAIY,WAAW,CAAC6B,KAAK,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,gEAAgE,CAAC;EACnF,CAAC,MAAM,IAAI9B,WAAW,CAACI,IAAI,EAAE;IAC3BhB,MAAM,GAAG2C,gBAAgB,CACvB5H,KAAK;IACL;IACA;IACA;IACA;IACA;IACAE,KAAK,CAACC,OAAO,CAAC0F,WAAW,CAACI,IAAI,CAAC,GAAGJ,WAAW,CAACI,IAAI,CAAC,CAAC,CAAC,GAAGJ,WAAW,CAACI,IAAI,EACxE/B,OACF,CAAC;EACH,CAAC,MAAM;IACLe,MAAM,GAAG;MAAEjF,KAAK,EAAEA;IAAM,CAAC;IACzB;EACF;EACA;EACA,IAAIiF,MAAM,CAACI,KAAK,EAAE;IAChB,OAAOJ,MAAM;EACf;EACA,IAAIA,MAAM,CAACjF,KAAK,KAAK,IAAI,EAAE;IACzB,IAAI6F,WAAW,CAACgC,KAAK,IAAIhC,WAAW,CAACgC,KAAK,CAACpG,OAAO,CAACwD,MAAM,CAACjF,KAAK,CAAC,GAAG,CAAC,EAAE;MACpE,OAAO;QAAEqF,KAAK,EAAE,SAAS;QAAEU,MAAM,EAAE;MAAU,CAAC;IAChD;IACA,IAAIF,WAAW,CAACiC,QAAQ,EAAE;MACxB,IAAI;QACFjC,WAAW,CAACiC,QAAQ,CAAC7C,MAAM,CAACjF,KAAK,CAAC;MACpC,CAAC,CAAC,OAAOqF,KAAK,EAAE;QACd,OAAO;UAAEA,KAAK,EAAEA,KAAK,CAAC0C;QAAQ,CAAC;MACjC;IACF;EACF;EACA,OAAO9C,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+C,gBAAgBA,CAAChI,KAAK,EAAE0H,KAAK,EAAE;EACtC,IAAI;IACF,IAAMO,WAAW,GAAGP,KAAK,CAAC1H,KAAK,CAAC;IAChC,IAAIiI,WAAW,KAAK9E,SAAS,EAAE;MAC7B,OAAO;QAAEnD,KAAK,EAAE;MAAK,CAAC;IACxB;IACA,OAAO;MAAEA,KAAK,EAAEiI;IAAY,CAAC;EAC/B,CAAC,CAAC,OAAO5C,KAAK,EAAE;IACd,IAAMJ,MAAM,GAAG;MAAEI,KAAK,EAAEA,KAAK,CAAC0C;IAAQ,CAAC;IACvC,IAAI1C,KAAK,CAACU,MAAM,EAAE;MAChBd,MAAM,CAACc,MAAM,GAAGV,KAAK,CAACU,MAAM;IAC9B;IACA,OAAOd,MAAM;EACf;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2C,gBAAgBA,CAAC5H,KAAK,EAAEiG,IAAI,EAAE/B,OAAO,EAAE;EAC9C,QAAQ+B,IAAI;IACV,KAAKnD,MAAM;MACT,OAAOkF,gBAAgB,CAAChI,KAAK,EAAEkI,kBAAU,CAAC;IAE5C,KAAK7E,MAAM;MACT,OAAO2E,gBAAgB,CAAChI,KAAK,EAAEmI,kBAAU,CAAC;IAE5C,KAAKC,IAAI;MACP,OAAOJ,gBAAgB,CAAChI,KAAK,EAAE,UAACA,KAAK;QAAA,OAAK,IAAAqI,gBAAQ,EAACrI,KAAK,EAAE;UAAEsI,UAAU,EAAEpE,OAAO,CAACoE;QAAW,CAAC,CAAC;MAAA,EAAC;IAEhG,KAAKC,OAAO;MACV,OAAOP,gBAAgB,CAAChI,KAAK,EAAEwI,mBAAW,CAAC;IAE7C;MACE,IAAI,OAAOvC,IAAI,KAAK,UAAU,EAAE;QAC9B,OAAO+B,gBAAgB,CAAChI,KAAK,EAAEiG,IAAI,CAAC;MACtC;MACA,MAAM,IAAI0B,KAAK,6BAAAlB,MAAA,CAA6BR,IAAI,IAAIA,IAAI,CAACrF,IAAI,IAAIqF,IAAI,CAAE,CAAC;EAC5E;AACF;AAEO,SAASwC,QAAQA,CAACC,MAAM,EAAEC,YAAY,EAAEC,UAAU,EAAE;EACzD,IAAI/J,CAAC,GAAG,CAAC;EACT,IAAIgK,SAAS,GAAG,EAAE;EAClB,IAAIC,SAAS;EACb,OAAOF,UAAU,GAAG/J,CAAC,GAAG6J,MAAM,CAACzI,MAAM,EAAE;IACrC,IAAM6I,UAAS,GAAGJ,MAAM,CAACE,UAAU,GAAG/J,CAAC,CAAC;IACxC,IAAIiK,UAAS,KAAKH,YAAY,EAAE;MAC9B,OAAO,CAACE,SAAS,EAAEhK,CAAC,CAAC;IACvB,CAAC,MACI,IAAIiK,UAAS,KAAK,GAAG,EAAE;MAC1B,IAAMC,KAAK,GAAGN,QAAQ,CAACC,MAAM,EAAE,GAAG,EAAEE,UAAU,GAAG/J,CAAC,GAAG,CAAC,CAAC;MACvDgK,SAAS,IAAIE,KAAK,CAAC,CAAC,CAAC;MACrBlK,CAAC,IAAI,GAAG,CAACoB,MAAM,GAAG8I,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC9I,MAAM;IACzC,CAAC,MACI;MACH4I,SAAS,IAAIC,UAAS;MACtBjK,CAAC,EAAE;IACL;EACF;EACA,OAAO,CAACgK,SAAS,EAAEhK,CAAC,CAAC;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASiI,UAAUA,CAAC4B,MAAM,EAAE5E,mBAAmB,EAAE;EACtD,IAAMkF,MAAM,GAAG,EAAE;EACjB,IAAIC,KAAK,GAAG,CAAC;EACb,OAAOA,KAAK,GAAGP,MAAM,CAACzI,MAAM,EAAE;IAC5B,IAAAiJ,SAAA,GAA4BT,QAAQ,CAACC,MAAM,EAAE5E,mBAAmB,EAAEmF,KAAK,CAAC;MAAAE,UAAA,GAAAxK,cAAA,CAAAuK,SAAA;MAAjEL,SAAS,GAAAM,UAAA;MAAElJ,MAAM,GAAAkJ,UAAA;IACxBF,KAAK,IAAIhJ,MAAM,GAAG6D,mBAAmB,CAAC7D,MAAM;IAC5C+I,MAAM,CAACjJ,IAAI,CAAC8I,SAAS,CAACO,IAAI,CAAC,CAAC,CAAC;EAC/B;EACA,OAAOJ,MAAM;AACf;;AAEA;AACA;AACA,IAAMxE,SAAS,GAAG,SAAZA,SAASA,CAAGqC,KAAK;EAAA,OAAIA,KAAK,CAAC,CAAC,CAAC,CAACE,GAAG,CAAC,UAACsC,CAAC,EAAExK,CAAC;IAAA,OAAKgI,KAAK,CAACE,GAAG,CAAC,UAAAtC,GAAG;MAAA,OAAIA,GAAG,CAAC5F,CAAC,CAAC;IAAA,EAAC;EAAA,EAAC;AAAA;AAE3E,SAAS0F,cAAcA,CAACN,MAAM,EAAE;EAC9B,SAAAqF,GAAA,MAAAC,aAAA,GAAkB1J,MAAM,CAAC+B,IAAI,CAACqC,MAAM,CAAC,EAAAqF,GAAA,GAAAC,aAAA,CAAAtJ,MAAA,EAAAqJ,GAAA,IAAE;IAAlC,IAAMhI,GAAG,GAAAiI,aAAA,CAAAD,GAAA;IACZ,IAAMzD,WAAW,GAAG5B,MAAM,CAAC3C,GAAG,CAAC;IAC/B;IACA,IAAIjD,OAAA,CAAOwH,WAAW,CAACI,IAAI,MAAK,QAAQ,IAAI,CAAC/F,KAAK,CAACC,OAAO,CAAC0F,WAAW,CAACI,IAAI,CAAC,EAAE;MAC5E,MAAM,IAAI0B,KAAK,CAAC,qFAAqF,CAAC;IACxG;IACA;IACA,IAAI,CAAC9B,WAAW,CAAC5B,MAAM,EAAE;MACvB,IAAI,CAAC4B,WAAW,CAACG,MAAM,EAAE;QACvB,MAAM,IAAI2B,KAAK,8CAAAlB,MAAA,CAA2CnF,GAAG,QAAI,CAAC;MACpE;IACF;EACF;AACF;AAEA,SAAS6F,YAAYA,CAACnH,KAAK,EAAE;EAC3B,OAAOA,KAAK,KAAKmD,SAAS,IAAInD,KAAK,KAAK,IAAI;AAC9C"}